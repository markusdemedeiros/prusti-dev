<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source of the Rust file `/home/runner/.cargo/registry/src/github.com-1ecc6299db9ec823/pest_meta-2.4.0/src/grammar.rs`."><meta name="keywords" content="rust, rustlang, rust-lang"><title>grammar.rs - source</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" href="../../normalize.css"><link rel="stylesheet" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" href="../../ayu.css" disabled><link rel="stylesheet" href="../../dark.css" disabled><link rel="stylesheet" href="../../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../../storage.js"></script><script defer src="../../source-script.js"></script><script defer src="../../source-files.js"></script><script defer src="../../main.js"></script><noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../../favicon.svg"></head><body class="rustdoc source"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"></nav><main><div class="width-limiter"><nav class="sub"><a class="sub-logo-container" href="../../pest_meta/index.html"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></a><form class="search-form"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../wheel.svg"></a></div></form></nav><section id="main-content" class="content"><div class="example-wrap"><pre class="src-line-numbers"><span id="1">1</span>
<span id="2">2</span>
</pre><pre class="rust"><code><span class="kw">pub struct </span>PestParser;
# [allow (dead_code , non_camel_case_types , clippy :: upper_case_acronyms)] # [derive (Clone , Copy , Debug , Eq , Hash , Ord , PartialEq , PartialOrd)] <span class="kw">pub enum </span>Rule { EOI , grammar_rules , grammar_rule , assignment_operator , opening_brace , closing_brace , opening_paren , closing_paren , opening_brack , closing_brack , modifier , silent_modifier , atomic_modifier , compound_atomic_modifier , non_atomic_modifier , expression , term , node , terminal , prefix_operator , infix_operator , postfix_operator , positive_predicate_operator , negative_predicate_operator , sequence_operator , choice_operator , optional_operator , repeat_operator , repeat_once_operator , repeat_exact , repeat_min , repeat_max , repeat_min_max , number , integer , comma , _push , peek_slice , identifier , alpha , alpha_num , string , insensitive_string , range , character , inner_str , inner_chr , escape , code , unicode , hex_digit , quote , single_quote , range_operator , newline , WHITESPACE , block_comment , COMMENT } # [allow (clippy :: all)] <span class="kw">impl </span>:: pest :: Parser &lt; <a href="#2">Rule</a> &gt; <span class="kw">for </span><a href="#1">PestParser</a> { <span class="kw">fn </span>parse &lt; <span class="lifetime">&#39;i </span>&gt; (rule : <a href="#2">Rule</a> , input : &amp; <span class="lifetime">&#39;i </span><a href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>) -&gt; :: std :: result :: <span class="prelude-ty">Result </span>&lt; :: pest :: iterators :: Pairs &lt; <span class="lifetime">&#39;i </span>, <a href="#2">Rule</a> &gt; , :: pest :: error :: Error &lt; <a href="#2">Rule</a> &gt; &gt; { <span class="kw">mod </span>rules { # ! [allow (clippy :: upper_case_acronyms)] <span class="kw">pub mod </span>hidden { <span class="kw">use super </span>:: <span class="kw">super </span>:: Rule ; # [inline] # [allow (dead_code , non_snake_case , unused_variables)] <span class="kw">pub fn </span>skip (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt; &gt; { <span class="kw">if </span>state . atomicity () == :: pest :: Atomicity :: NonAtomic { <a href="#2">state</a> . sequence (| state | { <a href="#2">state</a> . repeat (| state | <span class="kw">super </span>:: visible :: WHITESPACE (<a href="#2">state</a>)) . and_then (| state | { <a href="#2">state</a> . repeat (| state | { <a href="#2">state</a> . sequence (| state | { <span class="kw">super </span>:: visible :: COMMENT (<a href="#2">state</a>) . and_then (| state | { <a href="#2">state</a> . repeat (| state | <span class="kw">super </span>:: visible :: WHITESPACE (<a href="#2">state</a>)) }) }) }) }) }) } <span class="kw">else </span>{ <span class="prelude-val">Ok </span>(<a href="#2">state</a>) } } } <span class="kw">pub mod </span>visible { <span class="kw">use super </span>:: <span class="kw">super </span>:: Rule ; # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>grammar_rules (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt; &gt; { <a href="#2">state</a> . sequence (| state | { <span class="self">self </span>:: SOI (<a href="#2">state</a>) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (<a href="#2">state</a>) }) . and_then (| state | { <a href="#2">state</a> . sequence (| state | { <span class="self">self </span>:: grammar_rule (<a href="#2">state</a>) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (<a href="#2">state</a>) }) . and_then (| state | { <a href="#2">state</a> . sequence (| state | { <a href="#2">state</a> . optional (| state | { <span class="self">self </span>:: grammar_rule (<a href="#2">state</a>) . and_then (| state | { <a href="#2">state</a> . repeat (| state | { <a href="#2">state</a> . sequence (| state | { <span class="kw">super </span>:: hidden :: skip (<a href="#2">state</a>) . and_then (| state | { <span class="self">self </span>:: grammar_rule (<a href="#2">state</a>) }) }) }) }) }) }) }) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (<a href="#2">state</a>) }) . and_then (| state | { <span class="self">self </span>:: EOI (<a href="#2">state</a>) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>grammar_rule (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt; &gt; { <a href="#2">state</a> . rule (Rule :: grammar_rule , | state | { <a href="#2">state</a> . sequence (| state | { <span class="self">self </span>:: identifier (<a href="#2">state</a>) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (<a href="#2">state</a>) }) . and_then (| state | { <span class="self">self </span>:: assignment_operator (<a href="#2">state</a>) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (<a href="#2">state</a>) }) . and_then (| state | { <a href="#2">state</a> . optional (| state | { <span class="self">self </span>:: modifier (<a href="#2">state</a>) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (<a href="#2">state</a>) }) . and_then (| state | { <span class="self">self </span>:: opening_brace (<a href="#2">state</a>) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (<a href="#2">state</a>) }) . and_then (| state | { <span class="self">self </span>:: expression (<a href="#2">state</a>) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (<a href="#2">state</a>) }) . and_then (| state | { <span class="self">self </span>:: closing_brace (<a href="#2">state</a>) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>assignment_operator (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt; &gt; { <a href="#2">state</a> . rule (Rule :: assignment_operator , | state | { <a href="#2">state</a> . match_string (<span class="string">&quot;=&quot;</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>opening_brace (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt; &gt; { <a href="#2">state</a> . rule (Rule :: opening_brace , | state | { <a href="#2">state</a> . match_string (<span class="string">&quot;{&quot;</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>closing_brace (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt; &gt; { <a href="#2">state</a> . rule (Rule :: closing_brace , | state | { <a href="#2">state</a> . match_string (<span class="string">&quot;}&quot;</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>opening_paren (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt; &gt; { <a href="#2">state</a> . rule (Rule :: opening_paren , | state | { <a href="#2">state</a> . match_string (<span class="string">&quot;(&quot;</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>closing_paren (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt; &gt; { <a href="#2">state</a> . rule (Rule :: closing_paren , | state | { <a href="#2">state</a> . match_string (<span class="string">&quot;)&quot;</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>opening_brack (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt; &gt; { <a href="#2">state</a> . rule (Rule :: opening_brack , | state | { <a href="#2">state</a> . match_string (<span class="string">&quot;[&quot;</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>closing_brack (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt; &gt; { <a href="#2">state</a> . rule (Rule :: closing_brack , | state | { <a href="#2">state</a> . match_string (<span class="string">&quot;]&quot;</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>modifier (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt; &gt; { <span class="self">self </span>:: silent_modifier (<a href="#2">state</a>) . or_else (| state | { <span class="self">self </span>:: atomic_modifier (<a href="#2">state</a>) }) . or_else (| state | { <span class="self">self </span>:: compound_atomic_modifier (<a href="#2">state</a>) }) . or_else (| state | { <span class="self">self </span>:: non_atomic_modifier (<a href="#2">state</a>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>silent_modifier (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt; &gt; { <a href="#2">state</a> . rule (Rule :: silent_modifier , | state | { <a href="#2">state</a> . match_string (<span class="string">&quot;_&quot;</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>atomic_modifier (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt; &gt; { <a href="#2">state</a> . rule (Rule :: atomic_modifier , | state | { <a href="#2">state</a> . match_string (<span class="string">&quot;@&quot;</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>compound_atomic_modifier (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt; &gt; { <a href="#2">state</a> . rule (Rule :: compound_atomic_modifier , | state | { <a href="#2">state</a> . match_string (<span class="string">&quot;$&quot;</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>non_atomic_modifier (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt; &gt; { <a href="#2">state</a> . rule (Rule :: non_atomic_modifier , | state | { <a href="#2">state</a> . match_string (<span class="string">&quot;!&quot;</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>expression (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt; &gt; { <a href="#2">state</a> . rule (Rule :: expression , | state | { <a href="#2">state</a> . sequence (| state | { <a href="#2">state</a> . optional (| state | { <span class="self">self </span>:: choice_operator (<a href="#2">state</a>) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (<a href="#2">state</a>) }) . and_then (| state | { <span class="self">self </span>:: term (<a href="#2">state</a>) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (<a href="#2">state</a>) }) . and_then (| state | { <a href="#2">state</a> . sequence (| state | { <a href="#2">state</a> . optional (| state | { <a href="#2">state</a> . sequence (| state | { <span class="self">self </span>:: infix_operator (<a href="#2">state</a>) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (<a href="#2">state</a>) }) . and_then (| state | { <span class="self">self </span>:: term (<a href="#2">state</a>) }) }) . and_then (| state | { <a href="#2">state</a> . repeat (| state | { <a href="#2">state</a> . sequence (| state | { <span class="kw">super </span>:: hidden :: skip (<a href="#2">state</a>) . and_then (| state | { <a href="#2">state</a> . sequence (| state | { <span class="self">self </span>:: infix_operator (<a href="#2">state</a>) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (<a href="#2">state</a>) }) . and_then (| state | { <span class="self">self </span>:: term (<a href="#2">state</a>) }) }) }) }) }) }) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>term (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt; &gt; { <a href="#2">state</a> . rule (Rule :: term , | state | { <a href="#2">state</a> . sequence (| state | { <a href="#2">state</a> . sequence (| state | { <a href="#2">state</a> . optional (| state | { <span class="self">self </span>:: prefix_operator (<a href="#2">state</a>) . and_then (| state | { <a href="#2">state</a> . repeat (| state | { <a href="#2">state</a> . sequence (| state | { <span class="kw">super </span>:: hidden :: skip (<a href="#2">state</a>) . and_then (| state | { <span class="self">self </span>:: prefix_operator (<a href="#2">state</a>) }) }) }) }) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (<a href="#2">state</a>) }) . and_then (| state | { <span class="self">self </span>:: node (<a href="#2">state</a>) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (<a href="#2">state</a>) }) . and_then (| state | { <a href="#2">state</a> . sequence (| state | { <a href="#2">state</a> . optional (| state | { <span class="self">self </span>:: postfix_operator (<a href="#2">state</a>) . and_then (| state | { <a href="#2">state</a> . repeat (| state | { <a href="#2">state</a> . sequence (| state | { <span class="kw">super </span>:: hidden :: skip (<a href="#2">state</a>) . and_then (| state | { <span class="self">self </span>:: postfix_operator (<a href="#2">state</a>) }) }) }) }) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>node (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt; &gt; { <a href="#2">state</a> . sequence (| state | { <span class="self">self </span>:: opening_paren (<a href="#2">state</a>) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (<a href="#2">state</a>) }) . and_then (| state | { <span class="self">self </span>:: expression (<a href="#2">state</a>) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (<a href="#2">state</a>) }) . and_then (| state | { <span class="self">self </span>:: closing_paren (<a href="#2">state</a>) }) }) . or_else (| state | { <span class="self">self </span>:: terminal (<a href="#2">state</a>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>terminal (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt; &gt; { <span class="self">self </span>:: _push (<a href="#2">state</a>) . or_else (| state | { <span class="self">self </span>:: peek_slice (<a href="#2">state</a>) }) . or_else (| state | { <span class="self">self </span>:: identifier (<a href="#2">state</a>) }) . or_else (| state | { <span class="self">self </span>:: string (<a href="#2">state</a>) }) . or_else (| state | { <span class="self">self </span>:: insensitive_string (<a href="#2">state</a>) }) . or_else (| state | { <span class="self">self </span>:: range (<a href="#2">state</a>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>prefix_operator (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt; &gt; { <span class="self">self </span>:: positive_predicate_operator (<a href="#2">state</a>) . or_else (| state | { <span class="self">self </span>:: negative_predicate_operator (<a href="#2">state</a>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>infix_operator (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt; &gt; { <span class="self">self </span>:: sequence_operator (<a href="#2">state</a>) . or_else (| state | { <span class="self">self </span>:: choice_operator (<a href="#2">state</a>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>postfix_operator (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt; &gt; { <span class="self">self </span>:: optional_operator (<a href="#2">state</a>) . or_else (| state | { <span class="self">self </span>:: repeat_operator (<a href="#2">state</a>) }) . or_else (| state | { <span class="self">self </span>:: repeat_once_operator (<a href="#2">state</a>) }) . or_else (| state | { <span class="self">self </span>:: repeat_exact (<a href="#2">state</a>) }) . or_else (| state | { <span class="self">self </span>:: repeat_min (<a href="#2">state</a>) }) . or_else (| state | { <span class="self">self </span>:: repeat_max (<a href="#2">state</a>) }) . or_else (| state | { <span class="self">self </span>:: repeat_min_max (<a href="#2">state</a>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>positive_predicate_operator (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt; &gt; { <a href="#2">state</a> . rule (Rule :: positive_predicate_operator , | state | { <a href="#2">state</a> . match_string (<span class="string">&quot;&amp;&quot;</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>negative_predicate_operator (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt; &gt; { <a href="#2">state</a> . rule (Rule :: negative_predicate_operator , | state | { <a href="#2">state</a> . match_string (<span class="string">&quot;!&quot;</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>sequence_operator (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt; &gt; { <a href="#2">state</a> . rule (Rule :: sequence_operator , | state | { <a href="#2">state</a> . match_string (<span class="string">&quot;~&quot;</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>choice_operator (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt; &gt; { <a href="#2">state</a> . rule (Rule :: choice_operator , | state | { <a href="#2">state</a> . match_string (<span class="string">&quot;|&quot;</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>optional_operator (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt; &gt; { <a href="#2">state</a> . rule (Rule :: optional_operator , | state | { <a href="#2">state</a> . match_string (<span class="string">&quot;?&quot;</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>repeat_operator (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt; &gt; { <a href="#2">state</a> . rule (Rule :: repeat_operator , | state | { <a href="#2">state</a> . match_string (<span class="string">&quot;*&quot;</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>repeat_once_operator (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt; &gt; { <a href="#2">state</a> . rule (Rule :: repeat_once_operator , | state | { <a href="#2">state</a> . match_string (<span class="string">&quot;+&quot;</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>repeat_exact (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt; &gt; { <a href="#2">state</a> . rule (Rule :: repeat_exact , | state | { <a href="#2">state</a> . sequence (| state | { <span class="self">self </span>:: opening_brace (<a href="#2">state</a>) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (<a href="#2">state</a>) }) . and_then (| state | { <span class="self">self </span>:: number (<a href="#2">state</a>) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (<a href="#2">state</a>) }) . and_then (| state | { <span class="self">self </span>:: closing_brace (<a href="#2">state</a>) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>repeat_min (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt; &gt; { <a href="#2">state</a> . rule (Rule :: repeat_min , | state | { <a href="#2">state</a> . sequence (| state | { <span class="self">self </span>:: opening_brace (<a href="#2">state</a>) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (<a href="#2">state</a>) }) . and_then (| state | { <span class="self">self </span>:: number (<a href="#2">state</a>) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (<a href="#2">state</a>) }) . and_then (| state | { <span class="self">self </span>:: comma (<a href="#2">state</a>) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (<a href="#2">state</a>) }) . and_then (| state | { <span class="self">self </span>:: closing_brace (<a href="#2">state</a>) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>repeat_max (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt; &gt; { <a href="#2">state</a> . rule (Rule :: repeat_max , | state | { <a href="#2">state</a> . sequence (| state | { <span class="self">self </span>:: opening_brace (<a href="#2">state</a>) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (<a href="#2">state</a>) }) . and_then (| state | { <span class="self">self </span>:: comma (<a href="#2">state</a>) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (<a href="#2">state</a>) }) . and_then (| state | { <span class="self">self </span>:: number (<a href="#2">state</a>) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (<a href="#2">state</a>) }) . and_then (| state | { <span class="self">self </span>:: closing_brace (<a href="#2">state</a>) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>repeat_min_max (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt; &gt; { <a href="#2">state</a> . rule (Rule :: repeat_min_max , | state | { <a href="#2">state</a> . sequence (| state | { <span class="self">self </span>:: opening_brace (<a href="#2">state</a>) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (<a href="#2">state</a>) }) . and_then (| state | { <span class="self">self </span>:: number (<a href="#2">state</a>) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (<a href="#2">state</a>) }) . and_then (| state | { <span class="self">self </span>:: comma (<a href="#2">state</a>) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (<a href="#2">state</a>) }) . and_then (| state | { <span class="self">self </span>:: number (<a href="#2">state</a>) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (<a href="#2">state</a>) }) . and_then (| state | { <span class="self">self </span>:: closing_brace (<a href="#2">state</a>) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>number (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt; &gt; { <a href="#2">state</a> . rule (Rule :: number , | state | { <a href="#2">state</a> . atomic (:: pest :: Atomicity :: Atomic , | state | { <a href="#2">state</a> . sequence (| state | { <a href="#2">state</a> . match_range (<span class="string">&#39;0&#39; </span>.. <span class="string">&#39;9&#39;</span>) . and_then (| state | { <a href="#2">state</a> . repeat (| state | { <a href="#2">state</a> . match_range (<span class="string">&#39;0&#39; </span>.. <span class="string">&#39;9&#39;</span>) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>integer (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt; &gt; { <a href="#2">state</a> . rule (Rule :: integer , | state | { <a href="#2">state</a> . atomic (:: pest :: Atomicity :: Atomic , | state | { <span class="self">self </span>:: number (<a href="#2">state</a>) . or_else (| state | { <a href="#2">state</a> . sequence (| state | { <a href="#2">state</a> . match_string (<span class="string">&quot;-&quot;</span>) . and_then (| state | { <a href="#2">state</a> . repeat (| state | { <a href="#2">state</a> . match_string (<span class="string">&quot;0&quot;</span>) }) }) . and_then (| state | { <a href="#2">state</a> . match_range (<span class="string">&#39;1&#39; </span>.. <span class="string">&#39;9&#39;</span>) }) . and_then (| state | { <a href="#2">state</a> . optional (| state | { <span class="self">self </span>:: number (<a href="#2">state</a>) }) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>comma (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt; &gt; { <a href="#2">state</a> . rule (Rule :: comma , | state | { <a href="#2">state</a> . match_string (<span class="string">&quot;,&quot;</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>_push (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt; &gt; { <a href="#2">state</a> . rule (Rule :: _push , | state | { <a href="#2">state</a> . sequence (| state | { <a href="#2">state</a> . match_string (<span class="string">&quot;PUSH&quot;</span>) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (<a href="#2">state</a>) }) . and_then (| state | { <span class="self">self </span>:: opening_paren (<a href="#2">state</a>) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (<a href="#2">state</a>) }) . and_then (| state | { <span class="self">self </span>:: expression (<a href="#2">state</a>) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (<a href="#2">state</a>) }) . and_then (| state | { <span class="self">self </span>:: closing_paren (<a href="#2">state</a>) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>peek_slice (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt; &gt; { <a href="#2">state</a> . rule (Rule :: peek_slice , | state | { <a href="#2">state</a> . sequence (| state | { <a href="#2">state</a> . match_string (<span class="string">&quot;PEEK&quot;</span>) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (<a href="#2">state</a>) }) . and_then (| state | { <span class="self">self </span>:: opening_brack (<a href="#2">state</a>) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (<a href="#2">state</a>) }) . and_then (| state | { <a href="#2">state</a> . optional (| state | { <span class="self">self </span>:: integer (<a href="#2">state</a>) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (<a href="#2">state</a>) }) . and_then (| state | { <span class="self">self </span>:: range_operator (<a href="#2">state</a>) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (<a href="#2">state</a>) }) . and_then (| state | { <a href="#2">state</a> . optional (| state | { <span class="self">self </span>:: integer (<a href="#2">state</a>) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (<a href="#2">state</a>) }) . and_then (| state | { <span class="self">self </span>:: closing_brack (<a href="#2">state</a>) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>identifier (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt; &gt; { <a href="#2">state</a> . rule (Rule :: identifier , | state | { <a href="#2">state</a> . atomic (:: pest :: Atomicity :: Atomic , | state | { <a href="#2">state</a> . sequence (| state | { <a href="#2">state</a> . lookahead (<span class="bool-val">false </span>, | state | { <a href="#2">state</a> . match_string (<span class="string">&quot;PUSH&quot;</span>) }) . and_then (| state | { <a href="#2">state</a> . match_string (<span class="string">&quot;_&quot;</span>) . or_else (| state | { <span class="self">self </span>:: alpha (<a href="#2">state</a>) }) }) . and_then (| state | { <a href="#2">state</a> . repeat (| state | { <a href="#2">state</a> . match_string (<span class="string">&quot;_&quot;</span>) . or_else (| state | { <span class="self">self </span>:: alpha_num (<a href="#2">state</a>) }) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>alpha (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt; &gt; { <a href="#2">state</a> . match_range (<span class="string">&#39;a&#39; </span>.. <span class="string">&#39;z&#39;</span>) . or_else (| state | { <a href="#2">state</a> . match_range (<span class="string">&#39;A&#39; </span>.. <span class="string">&#39;Z&#39;</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>alpha_num (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt; &gt; { <span class="self">self </span>:: alpha (<a href="#2">state</a>) . or_else (| state | { <a href="#2">state</a> . match_range (<span class="string">&#39;0&#39; </span>.. <span class="string">&#39;9&#39;</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>string (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt; &gt; { <a href="#2">state</a> . atomic (:: pest :: Atomicity :: CompoundAtomic , | state | { <a href="#2">state</a> . rule (Rule :: string , | state | { <a href="#2">state</a> . sequence (| state | { <span class="self">self </span>:: quote (<a href="#2">state</a>) . and_then (| state | { <span class="self">self </span>:: inner_str (<a href="#2">state</a>) }) . and_then (| state | { <span class="self">self </span>:: quote (<a href="#2">state</a>) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>insensitive_string (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt; &gt; { <a href="#2">state</a> . rule (Rule :: insensitive_string , | state | { <a href="#2">state</a> . sequence (| state | { <a href="#2">state</a> . match_string (<span class="string">&quot;^&quot;</span>) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (<a href="#2">state</a>) }) . and_then (| state | { <span class="self">self </span>:: string (<a href="#2">state</a>) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>range (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt; &gt; { <a href="#2">state</a> . rule (Rule :: range , | state | { <a href="#2">state</a> . sequence (| state | { <span class="self">self </span>:: character (<a href="#2">state</a>) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (<a href="#2">state</a>) }) . and_then (| state | { <span class="self">self </span>:: range_operator (<a href="#2">state</a>) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (<a href="#2">state</a>) }) . and_then (| state | { <span class="self">self </span>:: character (<a href="#2">state</a>) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>character (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt; &gt; { <a href="#2">state</a> . atomic (:: pest :: Atomicity :: CompoundAtomic , | state | { <a href="#2">state</a> . rule (Rule :: character , | state | { <a href="#2">state</a> . sequence (| state | { <span class="self">self </span>:: single_quote (<a href="#2">state</a>) . and_then (| state | { <span class="self">self </span>:: inner_chr (<a href="#2">state</a>) }) . and_then (| state | { <span class="self">self </span>:: single_quote (<a href="#2">state</a>) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>inner_str (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt; &gt; { <a href="#2">state</a> . rule (Rule :: inner_str , | state | { <a href="#2">state</a> . atomic (:: pest :: Atomicity :: Atomic , | state | { <a href="#2">state</a> . sequence (| state | { <span class="kw">let </span>strings = [<span class="string">&quot;\&quot;&quot; </span>, <span class="string">&quot;\\&quot;</span>] ; <a href="#2">state</a> . skip_until (&amp; <a href="#2">strings</a>) . and_then (| state | { <a href="#2">state</a> . optional (| state | { <a href="#2">state</a> . sequence (| state | { <span class="self">self </span>:: escape (<a href="#2">state</a>) . and_then (| state | { <span class="self">self </span>:: inner_str (<a href="#2">state</a>) }) }) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>inner_chr (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt; &gt; { <a href="#2">state</a> . rule (Rule :: inner_chr , | state | { <a href="#2">state</a> . atomic (:: pest :: Atomicity :: Atomic , | state | { <span class="self">self </span>:: escape (<a href="#2">state</a>) . or_else (| state | { <span class="self">self </span>:: ANY (<a href="#2">state</a>) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>escape (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt; &gt; { <a href="#2">state</a> . rule (Rule :: escape , | state | { <a href="#2">state</a> . atomic (:: pest :: Atomicity :: Atomic , | state | { <a href="#2">state</a> . sequence (| state | { <a href="#2">state</a> . match_string (<span class="string">&quot;\\&quot;</span>) . and_then (| state | { <a href="#2">state</a> . match_string (<span class="string">&quot;\&quot;&quot;</span>) . or_else (| state | { <a href="#2">state</a> . match_string (<span class="string">&quot;\\&quot;</span>) }) . or_else (| state | { <a href="#2">state</a> . match_string (<span class="string">&quot;r&quot;</span>) }) . or_else (| state | { <a href="#2">state</a> . match_string (<span class="string">&quot;n&quot;</span>) }) . or_else (| state | { <a href="#2">state</a> . match_string (<span class="string">&quot;t&quot;</span>) }) . or_else (| state | { <a href="#2">state</a> . match_string (<span class="string">&quot;0&quot;</span>) }) . or_else (| state | { <a href="#2">state</a> . match_string (<span class="string">&quot;&#39;&quot;</span>) }) . or_else (| state | { <span class="self">self </span>:: code (<a href="#2">state</a>) }) . or_else (| state | { <span class="self">self </span>:: unicode (<a href="#2">state</a>) }) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>code (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt; &gt; { <a href="#2">state</a> . rule (Rule :: code , | state | { <a href="#2">state</a> . atomic (:: pest :: Atomicity :: Atomic , | state | { <a href="#2">state</a> . sequence (| state | { <a href="#2">state</a> . match_string (<span class="string">&quot;x&quot;</span>) . and_then (| state | { <span class="self">self </span>:: hex_digit (<a href="#2">state</a>) }) . and_then (| state | { <span class="self">self </span>:: hex_digit (<a href="#2">state</a>) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>unicode (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt; &gt; { <a href="#2">state</a> . rule (Rule :: unicode , | state | { <a href="#2">state</a> . atomic (:: pest :: Atomicity :: Atomic , | state | { <a href="#2">state</a> . sequence (| state | { <a href="#2">state</a> . match_string (<span class="string">&quot;u&quot;</span>) . and_then (| state | { <span class="self">self </span>:: opening_brace (<a href="#2">state</a>) }) . and_then (| state | { <a href="#2">state</a> . sequence (| state | { <span class="self">self </span>:: hex_digit (<a href="#2">state</a>) . and_then (| state | { <span class="self">self </span>:: hex_digit (<a href="#2">state</a>) }) . and_then (| state | { <a href="#2">state</a> . optional (| state | { <span class="self">self </span>:: hex_digit (<a href="#2">state</a>) }) }) . and_then (| state | { <a href="#2">state</a> . optional (| state | { <span class="self">self </span>:: hex_digit (<a href="#2">state</a>) }) }) . and_then (| state | { <a href="#2">state</a> . optional (| state | { <span class="self">self </span>:: hex_digit (<a href="#2">state</a>) }) }) . and_then (| state | { <a href="#2">state</a> . optional (| state | { <span class="self">self </span>:: hex_digit (<a href="#2">state</a>) }) }) }) }) . and_then (| state | { <span class="self">self </span>:: closing_brace (<a href="#2">state</a>) }) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>hex_digit (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt; &gt; { <a href="#2">state</a> . rule (Rule :: hex_digit , | state | { <a href="#2">state</a> . atomic (:: pest :: Atomicity :: Atomic , | state | { <a href="#2">state</a> . match_range (<span class="string">&#39;0&#39; </span>.. <span class="string">&#39;9&#39;</span>) . or_else (| state | { <a href="#2">state</a> . match_range (<span class="string">&#39;a&#39; </span>.. <span class="string">&#39;f&#39;</span>) }) . or_else (| state | { <a href="#2">state</a> . match_range (<span class="string">&#39;A&#39; </span>.. <span class="string">&#39;F&#39;</span>) }) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>quote (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt; &gt; { <a href="#2">state</a> . rule (Rule :: quote , | state | { <a href="#2">state</a> . match_string (<span class="string">&quot;\&quot;&quot;</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>single_quote (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt; &gt; { <a href="#2">state</a> . rule (Rule :: single_quote , | state | { <a href="#2">state</a> . match_string (<span class="string">&quot;&#39;&quot;</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>range_operator (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt; &gt; { <a href="#2">state</a> . rule (Rule :: range_operator , | state | { <a href="#2">state</a> . match_string (<span class="string">&quot;..&quot;</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>newline (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt; &gt; { <a href="#2">state</a> . match_string (<span class="string">&quot;\n&quot;</span>) . or_else (| state | { <a href="#2">state</a> . match_string (<span class="string">&quot;\r\n&quot;</span>) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>WHITESPACE (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt; &gt; { <a href="#2">state</a> . atomic (:: pest :: Atomicity :: Atomic , | state | { <a href="#2">state</a> . match_string (<span class="string">&quot; &quot;</span>) . or_else (| state | { <a href="#2">state</a> . match_string (<span class="string">&quot;\t&quot;</span>) }) . or_else (| state | { <span class="self">self </span>:: newline (<a href="#2">state</a>) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>block_comment (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt; &gt; { <a href="#2">state</a> . sequence (| state | { <a href="#2">state</a> . match_string (<span class="string">&quot;/*&quot;</span>) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (<a href="#2">state</a>) }) . and_then (| state | { <a href="#2">state</a> . sequence (| state | { <a href="#2">state</a> . optional (| state | { <span class="self">self </span>:: block_comment (<a href="#2">state</a>) . or_else (| state | { <a href="#2">state</a> . sequence (| state | { <a href="#2">state</a> . lookahead (<span class="bool-val">false </span>, | state | { <a href="#2">state</a> . match_string (<span class="string">&quot;*/&quot;</span>) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (<a href="#2">state</a>) }) . and_then (| state | { <span class="self">self </span>:: ANY (<a href="#2">state</a>) }) }) }) . and_then (| state | { <a href="#2">state</a> . repeat (| state | { <a href="#2">state</a> . sequence (| state | { <span class="kw">super </span>:: hidden :: skip (<a href="#2">state</a>) . and_then (| state | { <span class="self">self </span>:: block_comment (<a href="#2">state</a>) . or_else (| state | { <a href="#2">state</a> . sequence (| state | { <a href="#2">state</a> . lookahead (<span class="bool-val">false </span>, | state | { <a href="#2">state</a> . match_string (<span class="string">&quot;*/&quot;</span>) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (<a href="#2">state</a>) }) . and_then (| state | { <span class="self">self </span>:: ANY (<a href="#2">state</a>) }) }) }) }) }) }) }) }) }) }) . and_then (| state | { <span class="kw">super </span>:: hidden :: skip (<a href="#2">state</a>) }) . and_then (| state | { <a href="#2">state</a> . match_string (<span class="string">&quot;*/&quot;</span>) }) }) } # [inline] # [allow (non_snake_case , unused_variables)] <span class="kw">pub fn </span>COMMENT (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt; &gt; { <a href="#2">state</a> . atomic (:: pest :: Atomicity :: Atomic , | state | { <span class="self">self </span>:: block_comment (<a href="#2">state</a>) . or_else (| state | { <a href="#2">state</a> . sequence (| state | { <a href="#2">state</a> . match_string (<span class="string">&quot;//&quot;</span>) . and_then (| state | { <a href="#2">state</a> . repeat (| state | { <a href="#2">state</a> . sequence (| state | { <a href="#2">state</a> . lookahead (<span class="bool-val">false </span>, | state | { <span class="self">self </span>:: newline (<a href="#2">state</a>) }) . and_then (| state | { <span class="self">self </span>:: ANY (<a href="#2">state</a>) }) }) }) }) }) }) }) } # [inline] # [allow (dead_code , non_snake_case , unused_variables)] <span class="kw">pub fn </span>ANY (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt; &gt; { <a href="#2">state</a> . skip (<span class="number">1</span>) } # [inline] # [allow (dead_code , non_snake_case , unused_variables)] <span class="kw">pub fn </span>EOI (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt; &gt; { <a href="#2">state</a> . rule (Rule :: EOI , | state | <a href="#2">state</a> . end_of_input ()) } # [inline] # [allow (dead_code , non_snake_case , unused_variables)] <span class="kw">pub fn </span>SOI (state : :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt;) -&gt; :: pest :: ParseResult &lt; :: std :: boxed :: Box &lt; :: pest :: ParserState &lt; <a href="#2">Rule</a> &gt;&gt; &gt; { <a href="#2">state</a> . start_of_input () } } <span class="kw">pub use </span><span class="self">self </span>:: visible :: * ; } :: pest :: state (<a href="#2">input</a> , | state | { <span class="kw">match </span><a href="#2">rule</a> { Rule :: grammar_rules =&gt; rules :: grammar_rules (<a href="#2">state</a>) , Rule :: grammar_rule =&gt; rules :: grammar_rule (<a href="#2">state</a>) , Rule :: assignment_operator =&gt; rules :: assignment_operator (<a href="#2">state</a>) , Rule :: opening_brace =&gt; rules :: opening_brace (<a href="#2">state</a>) , Rule :: closing_brace =&gt; rules :: closing_brace (<a href="#2">state</a>) , Rule :: opening_paren =&gt; rules :: opening_paren (<a href="#2">state</a>) , Rule :: closing_paren =&gt; rules :: closing_paren (<a href="#2">state</a>) , Rule :: opening_brack =&gt; rules :: opening_brack (<a href="#2">state</a>) , Rule :: closing_brack =&gt; rules :: closing_brack (<a href="#2">state</a>) , Rule :: modifier =&gt; rules :: modifier (<a href="#2">state</a>) , Rule :: silent_modifier =&gt; rules :: silent_modifier (<a href="#2">state</a>) , Rule :: atomic_modifier =&gt; rules :: atomic_modifier (<a href="#2">state</a>) , Rule :: compound_atomic_modifier =&gt; rules :: compound_atomic_modifier (<a href="#2">state</a>) , Rule :: non_atomic_modifier =&gt; rules :: non_atomic_modifier (<a href="#2">state</a>) , Rule :: expression =&gt; rules :: expression (<a href="#2">state</a>) , Rule :: term =&gt; rules :: term (<a href="#2">state</a>) , Rule :: node =&gt; rules :: node (<a href="#2">state</a>) , Rule :: terminal =&gt; rules :: terminal (<a href="#2">state</a>) , Rule :: prefix_operator =&gt; rules :: prefix_operator (<a href="#2">state</a>) , Rule :: infix_operator =&gt; rules :: infix_operator (<a href="#2">state</a>) , Rule :: postfix_operator =&gt; rules :: postfix_operator (<a href="#2">state</a>) , Rule :: positive_predicate_operator =&gt; rules :: positive_predicate_operator (<a href="#2">state</a>) , Rule :: negative_predicate_operator =&gt; rules :: negative_predicate_operator (<a href="#2">state</a>) , Rule :: sequence_operator =&gt; rules :: sequence_operator (<a href="#2">state</a>) , Rule :: choice_operator =&gt; rules :: choice_operator (<a href="#2">state</a>) , Rule :: optional_operator =&gt; rules :: optional_operator (<a href="#2">state</a>) , Rule :: repeat_operator =&gt; rules :: repeat_operator (<a href="#2">state</a>) , Rule :: repeat_once_operator =&gt; rules :: repeat_once_operator (<a href="#2">state</a>) , Rule :: repeat_exact =&gt; rules :: repeat_exact (<a href="#2">state</a>) , Rule :: repeat_min =&gt; rules :: repeat_min (<a href="#2">state</a>) , Rule :: repeat_max =&gt; rules :: repeat_max (<a href="#2">state</a>) , Rule :: repeat_min_max =&gt; rules :: repeat_min_max (<a href="#2">state</a>) , Rule :: number =&gt; rules :: number (<a href="#2">state</a>) , Rule :: integer =&gt; rules :: integer (<a href="#2">state</a>) , Rule :: comma =&gt; rules :: comma (<a href="#2">state</a>) , Rule :: _push =&gt; rules :: _push (<a href="#2">state</a>) , Rule :: peek_slice =&gt; rules :: peek_slice (<a href="#2">state</a>) , Rule :: identifier =&gt; rules :: identifier (<a href="#2">state</a>) , Rule :: alpha =&gt; rules :: alpha (<a href="#2">state</a>) , Rule :: alpha_num =&gt; rules :: alpha_num (<a href="#2">state</a>) , Rule :: string =&gt; rules :: string (<a href="#2">state</a>) , Rule :: insensitive_string =&gt; rules :: insensitive_string (<a href="#2">state</a>) , Rule :: range =&gt; rules :: range (<a href="#2">state</a>) , Rule :: character =&gt; rules :: character (<a href="#2">state</a>) , Rule :: inner_str =&gt; rules :: inner_str (<a href="#2">state</a>) , Rule :: inner_chr =&gt; rules :: inner_chr (<a href="#2">state</a>) , Rule :: escape =&gt; rules :: escape (<a href="#2">state</a>) , Rule :: code =&gt; rules :: code (<a href="#2">state</a>) , Rule :: unicode =&gt; rules :: unicode (<a href="#2">state</a>) , Rule :: hex_digit =&gt; rules :: hex_digit (<a href="#2">state</a>) , Rule :: quote =&gt; rules :: quote (<a href="#2">state</a>) , Rule :: single_quote =&gt; rules :: single_quote (<a href="#2">state</a>) , Rule :: range_operator =&gt; rules :: range_operator (<a href="#2">state</a>) , Rule :: newline =&gt; rules :: newline (<a href="#2">state</a>) , Rule :: WHITESPACE =&gt; rules :: WHITESPACE (<a href="#2">state</a>) , Rule :: block_comment =&gt; rules :: block_comment (<a href="#2">state</a>) , Rule :: COMMENT =&gt; rules :: COMMENT (<a href="#2">state</a>) , Rule :: EOI =&gt; rules :: EOI (<a href="#2">state</a>) } }) } }
</code></pre></div>
</section></div></main><div id="rustdoc-vars" data-root-path="../../" data-current-crate="pest_meta" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.67.0-nightly (95a3a7277 2022-10-31)" ></div></body></html>